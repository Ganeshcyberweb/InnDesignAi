import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { prisma } from '@/lib/database';

// Helper function to parse budget range string to numeric value
function parseBudget(budgetRange: string): number | null {
  if (!budgetRange) return null;
  
  // Extract the first number from strings like "$1,000 - $5,000" or "$5,000+"
  const match = budgetRange.match(/\$?([\d,]+)/);
  if (match) {
    const numStr = match[1].replace(/,/g, '');
    const value = parseInt(numStr, 10);
    return isNaN(value) ? null : value;
  }
  
  return null;
}

export async function POST(request: NextRequest) {
  const startTime = Date.now();

  try {
    console.log('\nüíæ === DESIGN SAVE REQUEST ===');

    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      console.log('‚ùå Authentication failed: No user session');
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    console.log('üîê User Authenticated:', {
      userId: user.id,
      email: user.email,
      timestamp: new Date().toISOString()
    });

    // Ensure user profile exists (create if missing)
    console.log('üë§ Checking/creating user profile...');
    let profile = await prisma.profile.findUnique({
      where: { userId: user.id }
    });

    if (!profile) {
      console.log('‚ö†Ô∏è Profile not found, creating new profile...');
      const { getOrCreateUserProfile } = await import('@/lib/database');
      const result = await getOrCreateUserProfile(user);

      if (result.error || !result.profile) {
        console.error('‚ùå Failed to create profile:', result.error);
        return NextResponse.json(
          { error: 'Failed to initialize user profile' },
          { status: 500 }
        );
      }

      profile = result.profile;
      console.log('‚úÖ Profile created:', profile.id);
    } else {
      console.log('‚úÖ Profile found:', profile.id);
    }

    const body = await request.json();
    const {
      inputPrompt,
      uploadedImageUrl,
      aiModelUsed,
      themes, // Array of theme designs
      formData, // Form data (room type, style, etc.)
      parentDesignId, // Optional: if this is a regeneration
      roiAnalysis, // Optional: ROI analysis text generated by AI
    } = body;

    // Calculate total images
    const totalImages = themes ? themes.reduce((acc: number, t: any) => acc + (t.images?.length || 0), 0) : 0;

    console.log('üìä Request Summary:', {
      promptLength: inputPrompt?.length || 0,
      hasUploadedImage: !!uploadedImageUrl,
      aiModel: aiModelUsed,
      themesCount: themes?.length || 0,
      totalImages,
      hasFormData: !!formData,
      isRegeneration: !!parentDesignId,
    });

    // Enhanced validation
    if (!inputPrompt || !aiModelUsed || !themes || themes.length === 0) {
      console.log('‚ùå Validation failed: Missing required fields');
      return NextResponse.json(
        { error: 'Missing required fields: inputPrompt, aiModelUsed, themes' },
        { status: 400 }
      );
    }

    // Validate prompt is not just whitespace
    if (inputPrompt.trim().length === 0) {
      console.log('‚ùå Validation failed: Empty prompt');
      return NextResponse.json(
        { error: 'Prompt cannot be empty' },
        { status: 400 }
      );
    }

    // Validate minimum prompt length
    if (inputPrompt.trim().length < 10) {
      console.log('‚ùå Validation failed: Prompt too short');
      return NextResponse.json(
        { error: 'Prompt must be at least 10 characters' },
        { status: 400 }
      );
    }

    // Determine if this is a regeneration or new design
    let generationNumber = 1;
    if (parentDesignId) {
      console.log('üîÑ Regeneration detected, validating parent design:', parentDesignId);

      const parentDesign = await prisma.design.findUnique({
        where: { id: parentDesignId },
        select: { generationNumber: true, userId: true },
      });

      if (!parentDesign) {
        console.log('‚ùå Parent design not found:', parentDesignId);
        return NextResponse.json(
          { error: 'Parent design not found' },
          { status: 404 }
        );
      }

      if (parentDesign.userId !== user.id) {
        console.log('‚ùå Unauthorized regeneration attempt:', {
          parentUserId: parentDesign.userId,
          requestUserId: user.id
        });
        return NextResponse.json(
          { error: 'Unauthorized to regenerate this design' },
          { status: 403 }
        );
      }

      generationNumber = parentDesign.generationNumber + 1;
      console.log('‚úÖ Parent design validated, generation number:', generationNumber);
    }

    // Generate a title based on form data or use default
    const title = formData?.roomType && formData?.stylePreference 
      ? `${formData.stylePreference} ${formData.roomType} Design`
      : 'Untitled Design';

    // Create the main Design record with preferences included
    console.log('\nüèóÔ∏è Creating Design record...');
    console.log('   Design data:', {
      userId: user.id,
      title,
      description: inputPrompt || formData?.prompt || null,
      roomType: formData?.roomType || null,
      style: formData?.stylePreference || null,
      mood: formData?.moodPreference || null,
      priority: formData?.priority || null,
      customRequirements: aiModelUsed || null,
      isPublic: false,
      // Preferences (merged into Design)
      size: formData?.roomSize || null,
      stylePreference: formData?.stylePreference || null,
      colorScheme: formData?.colorPalette || null,
      materialPreferences: formData?.materialPreference || null,
      otherRequirements: formData?.prompt || null,
      budget: formData?.budgetRange ? parseBudget(formData.budgetRange) : null,
      generationNumber,
      // ROI Analysis
      roiNotes: roiAnalysis || null,
      hasROIAnalysis: !!roiAnalysis,
    });

    const designCreateStart = Date.now();

    const design = await prisma.design.create({
      data: {
        userId: user.id,
        title,
        description: inputPrompt || formData?.prompt || null,
        roomType: formData?.roomType || null,
        style: formData?.stylePreference || null,
        mood: formData?.moodPreference || null,
        priority: formData?.priority || null,
        customRequirements: aiModelUsed || null,
        imageUrl: uploadedImageUrl || null,
        isPublic: false,
        // Preferences fields (merged into Design)
        size: formData?.roomSize || null,
        stylePreference: formData?.stylePreference || null,
        colorScheme: formData?.colorPalette || null,
        materialPreferences: formData?.materialPreference || null,
        otherRequirements: formData?.prompt || null,
        budget: formData?.budgetRange ? parseBudget(formData.budgetRange) : null,
        // Regeneration chain tracking
        parentId: parentDesignId || null,
        generationNumber,
        // ROI Analysis
        roiNotes: roiAnalysis || null,
      },
    });    const designCreateDuration = Date.now() - designCreateStart;
    console.log('‚úÖ Design created:', {
      designId: design.id,
      generationNumber: design.generationNumber,
      status: design.status,
      duration: `${designCreateDuration}ms`
    });

    // Create design outputs for each theme and view
    console.log('\nüì∏ Creating DesignOutput records...');
    console.log('‚ÑπÔ∏è All images should already be uploaded to R2 - expecting URLs only');
    
    const designOutputs = [];
    let outputIndex = 0;

    for (const theme of themes) {
      for (let i = 0; i < theme.images.length; i++) {
        outputIndex++;
        const imageData = theme.images[i];
        const viewName = i === 0 ? 'Main View' : 'Detail View';
        const variationName = `${theme.label} - ${viewName}`;

        console.log(`\n   üì¶ [${outputIndex}/${totalImages}] Processing: ${variationName}`);
        console.log(`   üì¶ Theme: ${theme.theme}, Label: ${theme.label}`);
        const outputCreateStart = Date.now();

        // Validate that we have a URL (not base64)
        const isR2Url = imageData.startsWith('https://');
        const isBase64Data = imageData.startsWith('data:image/');

        if (!isR2Url && !isBase64Data) {
          console.error(`   ‚ùå Invalid image data format for output ${outputIndex}`);
          return NextResponse.json(
            { error: `Invalid image data format for output ${outputIndex}. Expected R2 URL or base64.` },
            { status: 400 }
          );
        }

        if (isBase64Data) {
          console.error(`   ‚ùå Base64 data detected for output ${outputIndex}`);
          console.error(`   ‚ùå Images should be uploaded to R2 before calling save API`);
          return NextResponse.json(
            { 
              error: `Base64 image detected at output ${outputIndex}. Please upload images to R2 first using /api/designs/upload-image endpoint.`,
              details: 'This prevents payload size issues. Upload images individually first, then send R2 URLs.'
            },
            { status: 400 }
          );
        }

        console.log(`   ‚úÖ Valid R2 URL detected`);
        console.log(`   ‚úÖ URL: ${imageData}`);

        console.log(`   üíæ Creating DesignOutput in database...`);
        const dbCreateStart = Date.now();

        const output = await prisma.designOutput.create({
          data: {
            designId: design.id,
            outputImageUrl: imageData, // R2 URL only
            variationName,
            generationParameters: {
              theme: theme.theme,
              themeLabel: theme.label,
              viewIndex: i,
              viewName,
            },
          },
        });

        const dbCreateDuration = Date.now() - dbCreateStart;
        const outputCreateDuration = Date.now() - outputCreateStart;
        
        console.log(`   ‚úÖ DesignOutput created in database (${dbCreateDuration}ms)`);
        console.log(`   ‚úÖ Output ID: ${output.id}`);
        console.log(`   ‚úÖ Total processing time: ${outputCreateDuration}ms\n`);

        designOutputs.push(output);
      }
    }

    console.log(`\n‚úÖ All ${designOutputs.length} DesignOutputs created`);

    // Preferences are now included directly in the Design model

    // Get user's total design count for activity tracking
    console.log('\nüë§ Fetching user profile statistics...');
    const userDesignCount = await prisma.design.count({
      where: { userId: user.id }
    });
    console.log(`   User has ${userDesignCount} total design(s)`);

    const totalDuration = Date.now() - startTime;

    console.log('\n‚úÖ === SAVE COMPLETE ===');
    console.log('Summary:', {
      designId: design.id,
      designOutputs: designOutputs.length,
      preferencesIncluded: !!(formData?.roomSize || formData?.designStyle || formData?.colorScheme),
      userTotalDesigns: userDesignCount,
      isRegeneration: !!parentDesignId,
      generationNumber: design.generationNumber,
      totalDuration: `${totalDuration}ms`
    });
    console.log('========================\n');

    return NextResponse.json({
      success: true,
      design: {
        ...design,
        designOutputs,
      },
      message: 'Design saved successfully',
      metadata: {
        outputsCount: designOutputs.length,
        userTotalDesigns: userDesignCount,
        processingTime: totalDuration,
      }
    });

  } catch (error) {
    const totalDuration = Date.now() - startTime;

    console.error('\n‚ùå === DESIGN SAVE ERROR ===');
    console.error('Error Type:', error?.constructor?.name);
    console.error('Error Message:', error instanceof Error ? error.message : String(error));
    console.error('Duration before error:', `${totalDuration}ms`);

    if (error instanceof Error && error.stack) {
      console.error('Stack Trace:', error.stack);
    }

    console.error('========================\n');

    return NextResponse.json(
      {
        error: 'Failed to save design',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
